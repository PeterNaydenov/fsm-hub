import e from"ask-for-promise";import n from"@peter.naydenov/stack";const t={_setTransitions:function(e,n){return function({reactivity:t,transformers:r},s={}){let a={},c={},o={},i={};return t.forEach(((t,r)=>{if(!(t instanceof Array))return void e._debugger(n.WRONG_REACTIVITY_RECORD,r+1);const s=t.length,[a,u,l,f]=t;if(!(4==s||3==s))return void e._debugger(n.WRONG_REACTIVITY_RECORD,r+1);const h=`${a}/${u}`;if(4==s){c[h]||(c[h]=[]),c[h].push(l);o[`${h}/${l}`]=f}3==s&&(i[h]||(i[h]=[]),i[h].push(l))})),r&&Object.keys(r).forEach((e=>{const n=r[e],t=s[n];t&&(a[e]=t)})),{transformers:a,subscribers:c,callbacks:i,actions:o}}},_debugger:function(e){return function(n,t){e.debug&&console.log(n,t)}},_callback:function(n,t){return function(r,s,a,c){const o=`${s}/${a}`,i=n.subscribers[o]||!1,u=n.callbacks[o]||!1,l=n.fnCallbacks,f=n.actions,h=[];let d;if(i||u){if(i&&i.forEach((e=>{if(!n.fsm[e])return void n._debugger(t.MISSING_FSM,i);const r=f[`${o}/${e}`],u=`${s}/${e}`,l=n.transformers[u];d="function"==typeof l?l(a,c):c,d||(d={},d.___internalFlag=!0);const _=n.fsm[e].update(r,d);h.push(_)})),u){let r=e();h.push(r.promise),u.forEach((e=>{const r=l[e],o=`${s}/${e}`,i=n.transformers[o];d="function"==typeof i?i(a,c):c,d.answer&&d.answer.hasOwnProperty("___internalFlag")&&(d.answer=void 0),"function"==typeof r?r(d):n._debugger(t.MISSING_FN,e)})),r.done()}Promise.all(h).then((()=>r.done()))}else r.done()}},addFsm:function(n,t){return function(r){Object.keys(r).forEach((s=>{function a(e){if(e&&(n.haveInternalRequest=!1),n.haveInternalRequest)return;let t=n.cacheInternal.isEmpty();if(n.cache.isEmpty()&&t)return void(n.lock=!1);let[r,s,a]=t?n.cache.pull():n.cacheInternal.pull();n.cache.isEmpty()&&(n.lock=!1),n.cacheInternal.isEmpty()&&(n.haveInternalRequest=!1),c(r,s,a)}function c(t,r,s){let c;if(!n.lock)return n.lock=!0,c=e(),c.onComplete((e=>a(!1))),void n._callback(c,t,r,s);if(s){if(n.haveInternalRequest)return void n.cacheInternal.push([[t,r,s]]);let c=e();return c.onComplete((e=>a(!0))),n.haveInternalRequest=!0,void n._callback(c,t,r,s)}n.cache.push([[t,r,s]])}n.fsm[s]?n._debugger(t.REGISTERED_FSM_NAME,s):(n.fsm[s]=r[s],n.fsm[s].on("update",((e,n)=>c(s,e,n))))}))}},addFunctions:function(e,n){return function(t){Object.keys(t).forEach((r=>{e.fnCallbacks[r]?e._debugger(n.REGISTERED_FUNCTION_NAME,r):e.fnCallbacks[r]=t[r]}))}}},r={WRONG_REACTIVITY_RECORD:"Error: Wrong reactivity record on row %s.",REGISTERED_FSM_NAME:'Warning: FSM "%s" is already registered.',REGISTERED_FUNCTION_NAME:'Warning: Function "%s" is already registered.',MISSING_FSM:'Warning: Fsm "%s" is not registered to the hub.',MISSING_FN:'Warning: Function "%s" is not registered to the hub.'};function s(s,a){const c=this,o=Object.keys(t);c.fsm={},c.fnCallbacks={},c.debug=s.debug||!1,c.cache=n({type:"FIFO"}),c.cacheInternal=n({type:"FIFO"}),c.wait=[],c.lock=!1,c.haveInternalRequest=!1,c.reactivityTask=!1,c.askForPromise=e,o.forEach((e=>{c[e]=t[e](c,r)}));const{transformers:i,subscribers:u,actions:l,callbacks:f}=c._setTransitions(s,a);c.transformers=i,c.subscribers=u,c.actions=l,c.callbacks=f}export{s as default};
